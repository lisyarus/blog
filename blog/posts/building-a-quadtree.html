<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta property="og:type" content="article" />
        <meta property="og:title" content="Building a quadtree in 22 lines of code">
        <meta property="og:site_name" content="lisyarus blog">
        <meta property="og:image" content="/blog/media/building-a-quadtree/cover.png" />
        <meta property="og:image:height" content="240" />
        <meta property="og:image:width" content="520" />
        <title>Building a quadtree in 22 lines of code | lisyarus blog</title>
        <link rel="stylesheet" href="/blog/styles/styles.css">
        <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
        <link rel="stylesheet" href="/blog/styles/panda-syntax-dark.css">
        <script src="/blog/scripts/highlight.min.js"></script>
        <script src="/blog/scripts/cpp.min.js"></script>
        <script src="/blog/scripts/glsl.min.js"></script>
        <script type="text/javascript">
            hljs.highlightAll();
        </script>
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
    </head>
    <body>
        <div id="page-content">
            <header id="blog-header"></header>
            <br/><center><div class="page-title">Building a quadtree in 22 lines of code</div></center><br/>
            <center><span class="post-date">2022 Dec 21</span></center><br/>

            <h2>Contents</h2>
            <ul id="contents"></ul>

            <h2 id="section-particles">Particles, particles, particles</h2>

            <p>Recently <a href="https://en.wikipedia.org/wiki/John_C._Baez">John Baez</a>, a well-known mathematician & science popularizer, posted <a href="https://mastodon.gamedev.place/@johncarlosbaez@mathstodon.xyz/109477712231518988">a thread</a> about <a href="https://en.wikipedia.org/wiki/Wigner_crystal">Wigner crystals</a>, and I, being such a sucker for particle simulations & cool visualizations, immediately decided I want to simulate these on my own. It took me a couple evenings, and the result can be downloaded from <a href="https://lisyarus.itch.io/wigner-crystal-simulation">here</a> (it's a PC app that runs on Windows and Linux). It looked like this:

            <center><video muted controls class="video-embed"><source src="/blog/media/building-a-quadtree/footage.mp4" type="video/mp4"></video></center>

            <p><i>Actually, now I'm working on a larger project &ndash; a generic particle simulator &ndash; which I've dreamt of making for a long time. I'll release it in a week or two with full code, stay tuned :) Here's a sneak peek:</i>

            <center><blockquote class="twitter-tweet" data-lang="en"><a href="https://twitter.com/lisyarus/status/1604943260002164751"></a></blockquote></center>

            <p>It's not really important what exactly happens here, but I'll note one thing: it computes the (electrostatic repulsion) forces between every pair of particles. This is a \( O(n^2) \) algorithm, i.e. a <i>slow</i> algorithm. I can hardly simulate more than 500 particles on my 8-core i9 CPU. Fortunately, there's a way (called <a href="https://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation">the Barnes-Hut algorithm</a>) to speed things up to \( O(n\cdot \log n) \) with some loss of precision as a tradeoff, and it requires <a href="https://en.wikipedia.org/wiki/Quadtree"><i>quadtrees</i></a>. Or <a href="https://en.wikipedia.org/wiki/Octree">octrees</a>, if you're doing it in 3D.</p>

            <p>Now, some 8 years ago I'd consider writing a quadtree a separate project worth several days of designing & implementing. These days I'm a bit more experienced and also tend to simplify things. I'm somewhere on the right slope of this diagram, sliding downwards:</p>

            <center><img src="/blog/media/building-a-quadtree/abstractions.jpeg" class="image-embed"></center>

            <p>The point is, implementing a quadtree took some 20 minutes or so for me. Let me show you how it works!</p>

            <h2 id="section-vocabulary">Vocabulary</h2>

            <p>First, let's define a few <i>vocabulary types</i> which will be useful later. We'll need a simple 2D point:</p>

            <pre><code class="language-cpp block">struct point
{
    float x, y;
};</code></pre>

            <p>and a 2D <a href="https://en.wikipedia.org/wiki/Minimum_bounding_box#Axis-aligned_minimum_bounding_box">axis-aligned box</a> (AABB):

            <pre><code class="language-cpp block">static constexpr float inf = std::numeric_limits&lt;float&gt;::infinity();

struct box
{
    point min{ inf,  inf};
    point max{-inf, -inf};
};</code></pre>

            <p>Notice that the default-constructed box is not just empty, but the <i>identity element</i> with respect to the operation of joining two boxes. This comes in handy quite often.</p>

            <p>You'd normally define a hundered useful operations on these types, but we'll only need a few: computing a midpoint of two points</p>

            <pre><code class="language-cpp block">point middle(point const & p1, point const & p2)
{
    return { (p1.x + p2.x) / 2.f, (p1.y + p2.y) / 2.f };
}</code></pre>

            <p>and extending a bounding box with a point, which I love to denote as <code>|=</code> because set union and logical or are quite similar:</p>

            <pre><code class="language-cpp block">struct box
{
    ...

    box & operator |= (point const & p)
    {
        min.x = std::min(min.x, p.x);
        min.y = std::min(min.y, p.y);
        max.x = std::max(max.x, p.x);
        max.y = std::max(max.y, p.y);
        return *this;
    }
};</code></pre>

            <p>We could also write a nice template function that computes the bounding box of a sequence of points:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
box bbox(Iterator begin, Iterator end)
{
    box result;
    for (auto it = begin; it != end; ++it)
        result |= *it;
    return result;
}</code></pre>

            <p>You could also define a <code>box operator | (box, point)</code> and use <code>std::accumulate</code> to implement this function.</p>

            <h2 id="section-defining-quadtree">Defining the quadtree</h2>

            <p>So, what's a quadtree anyway? It's a tree data structure where each node covers a rectangular area of the plane; this area is split in 4 equal parts by bisecting along X and Y coordinates, and the node's children, if present, cover these parts, so that a node has at most 4 children. These child nodes can have their own children, and so on. When to stop this recursion depends on your usecase. Nodes can also store some useful information, like points that they contain, objects they intersect, and so on, and can be used to speed-up various queries, like what points are contained in some rectangle, or what point is closest to some point, etc.<.

            <center><img src="/blog/media/building-a-quadtree/quadtree.png" class="image-embed"></center>

            <p>In our case, we have a set of points (which are positions of particles, but that's not important), and we need to build the quadtree in such a way that every leaf node (i.e. node without children) contains exactly one input point. (That's not always possible, which we'll discuss later.)</p>

            <p>So, how do we represent a quadtree in code? You might've started thinking about representing nodes as heap-allocated objects that store smart pointers to their children, something like</p>

            <pre><code class="language-cpp block">struct node
{
    std::unique_ptr&lt;node&gt; children[2][2];
};

struct quadtree
{
    box bbox;
    std::unique_ptr&lt;node&gt; root;
};</code></pre>

            <p>but there's a much, much better way: store all nodes in a <i>single array</i>, and use <i>array indices</i> as node IDs instead of pointers. Something like</p>

            <pre><code class="language-cpp block">using node_id = std::uint32_t;

static constexpr node_id null = node_id(-1);

struct node
{
    node_id children[2][2]{
        {null, null},
        {null, null}
    };
};

struct quadtree
{
    box bbox;
    node_id root;
    std::vector&lt;node&gt; nodes;
};</code></pre>

            <p>So, why is it better?</p>

            <ol>
                <li><b>Fewer memory allocations</b>. Actually, only one allocation is needed since you can compute an upper bound on the total number of nodes! But even without that all we need is a few allocations as the <code>vector</code> grows exponentially while we <code>push_back</code> nodes into it, compared to a single allocation for every node with the first approach. <i>You could write your own allocator for this task, but that feels more like hiding the problem than solving it.</i></li>
                <li><b>Smaller memory size</b>. See, you can't control the size of a pointer: if your system is 64-bit, like most today's desktop systems are, then your pointers occupy 8 bytes each, end of story. With indices, we can be more careful with using our memory, and e.g. use 32-bit indices if we are sure we'll never have more than 4294967296 nodes in the tree (which is a pretty good assumption, if you ask me). That's half the original memory size! We could even use 16-bit indices maybe. Remember that it's not only about memory size per se: smaller node size means more nodes can fit into a cache line, meaning faster iteration over nodes.</li>
                <li><b>Faster deletion</b>. Deleting the first version is slow because it's a recursive procedure that iterates over the whole tree and deletes nodes one by one, issuing a <code>free</code> call for every visited node, wasting CPU time on function calls and eating up the stack. Deleting the second version is a single <code>free</code> call somewhere in the <code>vector</code> internals!</li>
                <li><b>Easier to copy</b>. Deep-copying the first version would require you to write a recursive function that does all the work of copying every node and recursively copying its children. (<i>N.B. Just switching <code>unique_ptr</code> to <code>shared_ptr</code> won't work: you'll end up with a "copy" that references the same tree.</i>) Deep-copying the second version is trivial, literally: it is already copyable and does exactly what it's supposed to, because we use indices instead of pointers.</li>
                <li><b>Easier to serialize</b>. Again, binary serialization of the first version requires a recursive function that would probably set up some indexing scheme for the nodes anyway. Serializing the second version is just a few <code>stream.write(ptr, size)</code> calls.</li>
                <li><b>More cache-friendly</b>. In the first version, the nodes will end up anywhere in memory, depending on what your allocator decides to do in that particular moment. In the second version, all nodes are tightly packed in memory, and iterating over them makes the poor CPU cache happy.</li>
            </ol>

            <p>Also notice that I don't store the bounding box of each node, since it can be easily computed when traversing the tree, and is rarely needed otherwise.</p>

            <h2 id="section-building-quadtree">Building the quadtree</h2>

            <p>It's time to actually build the quadtree. We'll make a function with a signature roughly like this:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
quadtree build(Iterator begin, Iterator end);</code></pre>

            <p>Here, <code>[begin, end)</code> is the sequence of points to build the quadtree on. This will still be a recursive function internally, something like</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    // Create a node with a specified bbox and set of points
    ...
}

template &lt;typename Iterator&gt;
quadtree build(Iterator begin, Iterator end)
{
    quadtree result;
    result.root = build_impl(result, bbox(begin, end), begin, end);
    return result;
}</code></pre>

            <p>So, how do we build a node? First, we check if the point sequence is empty, and if it is, return a null node ID:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    if (begin == end)
        return null;

    ...
}</code></pre>

            <p>Then, check if we are a leaf node, i.e. if we contain just a single point, and create the node:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    if (begin == end)
        return null;

    node_id result = tree.nodes.size();
    tree.nodes.emplace_back();

    if (begin + 1 == end) return result;

    ...
}</code></pre>

            <p>Otherwise, we need to split the input points into four parts, each corresponding to one of the quadrants of the bounding box. This is where the C++ header <code>&lt;algorithm&gt;</code> comes in handy, specifically the <a href="https://en.cppreference.com/w/cpp/algorithm/partition"><code>std::partition</code></a> function: it splits a sequence of objects into two parts depending on whether they satisfy some predicate. It does that in-place, meaning no allocations again, and in linear time, i.e. as fast as possible.</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    ...

    point center = middle(bbox.min, bbox.max);

    // Split the points along Y
    Iterator split_y = std::partition(
        begin,
        end,
        [center](point const & p){
            return p.y < center.y;
        }
    );

    // Now, [begin, split_y) is the lower half,
    // and [split_y, end) is the upper half.

    // Split the lower half along X
    Iterator split_x_lower = std::partition(
        begin,
        split_y,
        [center](point const & p){
            return p.x < center.x;
        }
    );

    // Split the upper half along X
    Iterator split_x_upper = std::partition(
        split_y,
        end,
        [center](point const & p){
            return p.x < center.x;
        }
    );

    ...
}</code></pre>

            <p>At this stage, we have split the input points into four ranges:</p>

            <ul>
                <li><code>[begin, split_x_lower)</code> are in the lower-left quadrant</li>
                <li><code>[split_x_lower, split_y)</code> are in the lower-right quadrant</li>
                <li><code>[split_y, split_x_upper)</code> are in the upper-left quadrant</li>
                <li><code>[split_x_upper, end)</code> are in the upper-right quadrant</li>
            </ul>

            <p>All what's left is actually creating a node and filling it with the recursively created children, properly computing their bounding boxes:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    ...

    tree.nodes[result].children[0][0] = 
        build_impl(tree,
            {
                bbox.min,
                center
            },
            begin, split_x_lower);

    tree.nodes[result].children[0][1] = 
        build_impl(tree,
            {
                {center.x, bbox.min.y},
                {bbox.max.x, center.y}
            },
            split_x_lower, split_y);

    tree.nodes[result].children[1][0] = 
        build_impl(tree,
            {
                {bbox.min.x, center.y},
                {center.x, bbox.max.y}
            },
            split_y, split_x_upper);

    tree.nodes[result].children[1][1] = 
        build_impl(tree,
            {
                center,
                bbox.max
            },
            split_x_upper, end);

    return result;
}</code></pre>

            <p>Here's a sketch with all the bounding box coordinates:</p>

            <center><img src="/blog/media/quadtree/bbox.png" class="image-embed"></center>

            <p>Notice that I'm indexing the children array as <code>children[y][x]</code>. Also note that I'm explicitly repeating <code>tree.nodes[result]</code> instead of storing it in a local reference <code>node & current = tree.nodes[result]</code>, because the <code>build_impl</code> function adds new nodes to the nodes array, and the reference might get invalidated.</p>

            <p>This looks like a lot of code, but if we stop splitting everything into multiple lines (monitors are wide these days!), we get something really neat:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    if (begin == end) return null;

    node_id result = tree.nodes.size();
    tree.nodes.emplace_back();
    
    if (begin + 1 == end) return result;

    point center = middle(bbox.min, bbox.max);

    auto bottom = [center](point const & p){ return p.y < center.y; };
    auto left   = [center](point const & p){ return p.x < center.x; };

    Iterator split_y = std::partition(begin, end, bottom);
    Iterator split_x_lower = std::partition(begin, split_y, left);
    Iterator split_x_upper = std::partition(split_y, end, left);

    tree.nodes[result].children[0][0] = build_impl(tree, { bbox.min, center }, begin, split_x_lower);
    tree.nodes[result].children[0][1] = build_impl(tree, { { center.x, bbox.min.y }, { bbox.max.x, center.y } }, split_x_lower, split_y);
    tree.nodes[result].children[1][0] = build_impl(tree, { { bbox.min.x, center.y }, { center.x, bbox.max.y } }, split_y, split_x_upper);
    tree.nodes[result].children[1][1] = build_impl(tree, { center, bbox.max }, split_x_upper, end);

    return result;
}</code></pre>

            <p>That's it! The implementation is 22 lines (including empty lines), as I've promised :)</p>

            <h2 id="section-filling-quadtree">Filling the quadtree with data</h2>

            <p>Now, this quadtree is a bit useless: right now it only stores the <i>structure</i> of the tree (i.e. parent-child relationships), but doesn't contain any useful data. The beauty of this implementation is that you can add any per-node data simply as a separate array of values. E.g. for the Barnes-Hut algorithm, one needs to store the center of mass and the total mass of all points inside a node:</p>

            <pre><code class="language-cpp block">struct quadtree
{
    box bbox;
    node_id root;
    std::vector&lt;node&gt; nodes;
    std::vector&lt;float&gt; mass;
    std::vector&lt;point&gt; center_of_mass;
};</code></pre>

            <p>All this data can be easily computed when creating a node, based on whether it is a leaf node or a node with children.</p>

            <h2 id="section-fixing-recursion">Fixing infinite recursion</h2>

            <p>There's a problem with our current algorithm: if there are two equal points in the input (which absolutely may happen in general!), we will try to subdivide the tree further and further, never reaching the <code>begin + 1 == end</code> condition (and probably facing a stack overflow due to large recursion depth). There are several ways to fix that. One is to actually check if all the points are equal:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end)
{
    ...
    
    if (std::equal(begin + 1, end, begin)) return result;

    ...
}</code></pre>

            <p>or we could put a hard limit on the maximal recursion depth:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end, std::size_t depth_limit)
{
    ...
    
    if (depth_limit == 0) return result;

    ...

    ... = build_impl(..., depth_limit - 1);
    ...
}

static constexpr std::size_t MAX_QUADTREE_DEPTH = 64;

template &lt;typename Iterator&gt;
quadtree build(Iterator begin, Iterator end)
{
    quadtree result;
    result.root = build_impl(result, bbox(begin, end),
        begin, end, MAX_QUADTREE_DEPTH);
    return result;
}</code></pre>

            <h2 id="section-storing-variable-data">Storing variable amounts of per-node data</h2>

            <p>At this point we've accepted that even leaf nodes can contain multiple points (either because they are equal, or because we've reached recursion depth). What if I wanted to store the set of points every leaf node contains? Do I have to store something like <code>std::vector&lt;point&gt;</code> for each node? That's a lot of allocations and cache misses, again. There's a better way: just store all the points for all nodes in a single vector, and store the first and one-after-last indices of the node's points for each node!</p>

            <pre><code class="language-cpp block">struct quadtree
{
    box bbox;
    node_id root;
    std::vector&lt;node&gt; nodes;
    std::vector&lt;point&gt; points;
    std::vector&lt;std::pair&lt;std::uint32_t, std::uint32_t&gt; node_points_range;
};</code></pre>

            <p>So, for a node with a certain <code>id</code>, the range of indices of points contained in it is <code>[node_points_range[id].first] .. node_points_range[id].second)</code>.</p>

            <p>We can do better: let's arrange our points in such a way that the points for node <code>id + 1</code> are stored directly after the points for the node <code>id</code>. Then, we don't need to know the end of the range of point indices for a node (the <code>.second</code> thing): points for node <code>id</code> end precisely where the points for node <code>id + 1</code> begin! So, we store something like</p>

            <pre><code class="language-cpp block">struct quadtree
{
    box bbox;
    node_id root;
    std::vector&lt;node&gt; nodes;
    std::vector&lt;point&gt; points;
    std::vector&lt;std::uint32_t&gt; node_points_begin;
};</code></pre>

            <p>It is useful to append the total number of points to <code>node_points_begin</code>, so that <code>node_points_begin.size() == nodes.size() + 1</code> and <code>node_points_begin.back() == points.size()</code>. This way, <code>node_points_begin[id + 1]</code> is valid even for the last node (with <code>id + 1 == nodes.size()</code>).</p>

            <p>So, how do we build the tree in such a way that points are stored in such a neat fashion? Surprise, surprise: they are already stored this way! When building a node, we're given the range of points this node contains. Even after we rearrange them to split into 4 quadrants, this still holds: they are a contiguous range of points that are contained in this node. The only problem is that we're using some used-provided iterators and not indices. This is easy to fix: just build the tree out of an <code>std::vector</code> of points:</p>

            <pre><code class="language-cpp block">quadtree build(std::vector&lt;point&gt; points)
{
    quadtree result;
    result.points = std::move(points);
    result.root = build_impl(result,
        bbox(result.points.begin, result.points.end),
        result.points.begin, result.points.end);
    result.node_points_begin.push_back(result.points.size());
    return result;
}</code></pre>

            <p>and compute the starting point index when building a node:</p>

            <pre><code class="language-cpp block">template &lt;typename Iterator&gt;
node_id build_impl(quadtree & tree, box const & bbox,
    Iterator begin, Iterator end, std::size_t depth_limit)
{
    ...
    
    tree.node_points_begin[result] =
        (begin - tree.points.begin());

    ...
}</code></pre>

            <p>We could make this <code>build_impl</code> function to be non-template now by either using indices directly instead of iterators (which would require a lot of boilerplate when calling <code>std::</code> algorithms, which still require iterators) or by using pointers to the contents of <code>tree.points</code> (which will be a painless swap: pointers <i>are</i> iterators).</p>

            <p>To iterate over the points of a node <code>id</code>, we simply do</p>

            <pre><code class="language-cpp block">for (auto i = tree.node_points_begin[id];
    i < tree.node_points_begin[id + 1]; ++i)
{
    do_something(tree.points[i]);
}</code></pre>

            <h2 id="section-conclusion">Conclusion</h2>

            <p>I've used quadtrees like this a large number of times and they've worked marvelously! As usual, use this code with caution, I might've made a few mistakes while writing the post.</p>

            <p>Hope you've learnt something, and thanks for reading.</p>

            <div id="end-section"></div>
            <div id="blog-footer"></div>
        </div>
        <script async src="/blog/scripts/header.js"></script>
    </body>
</html>