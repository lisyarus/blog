<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <title>Skeletal animation in glTF | lisyarus blog</title>
        <link rel="stylesheet" href="/blog/styles/styles.css">
        <link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico">
        <link rel="stylesheet" href="/blog/styles/panda-syntax-dark.css">
        <script src="/blog/scripts/highlight.min.js"></script>
        <script src="/blog/scripts/cpp.min.js"></script>
        <script src="/blog/scripts/glsl.min.js"></script>
        <script type="text/javascript">
            hljs.highlightAll();
        </script>
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    </head>
    <body>
        <div id="page-content">
            <header id="blog-header"></header>
            <br/><center><div class="page-title">Skeletal animation in glTF</div></center><br/>
            <center><span class="post-date">2023 Jul 3</span></center><br/>

            <p>Recently (well, a few months ago), I was adding support for animated models in <a href="https://store.steampowered.com/app/2403100/Costa_Verde_Transport_Department">my traffic simulation game</a>. Specifically, I wanted to animate windmills:</p>

            <center><video autoplay muted loop class="video-embed"><source src="/blog/media/gltf-animation/windmill.mp4" type="video/mp4"></video></center>

            <p>Of course, this is extremely easy to hard-code (have two objects, one static and one rotating). However, I was planning to add more animations later, so I decided to implement a proper solution.</p>

            <p>Previously I used a crappy ad-hoc binary format for models and animations, but I've recently switched to <a href="https://www.khronos.org/gltf">glTF</a> for a number of reasons:</p>

            <ul>
                <li>It is easy to parse: JSON metadata + raw binary vertex data</li>
                <li>It is easy to render: models are stored in a format that maps directly to graphics API's</li>
                <li>It is compact enough (the heavy stuff &ndash; vertex data &ndash; is stored in binary)</li>
                <li>It is widespread and extensible</li>
                <li>It supports skeletal animations</li>
            </ul>

            <p>Using glTF models means it is easy for others to extend the game (to author mods, for example).</p>

            <p>Unfortunately, finding a good resource on skeletal animation with glTF specifically seemed impossible. All tutorials cover some older formats, while the glTF specification, being mostly quite verbose and precise, is unusually terse when it comes to the interpretation of the animation data. I guess it should be obvious to experts, but I'm not one of them, and if you're not either &ndash; this is an article for you :)</p>

            <p><i>Btw, I ended up reverse-engineering <a href="https://twitter.com/SaschaWillems2">Sascha Willems</a>'s animation code in his <a href="https://github.com/SaschaWillems/Vulkan-glTF-PBR">Vulkan + glTF</a> example renderer to figure out how to do this properly.</i></p>

            <h2>Contents</h2>
            <ul id="contents"></ul>

            <h2 id="section-skeletal-animation">Skeletal animation</h2>

            <p><i>If you already know what skeletal animation is, you can safely skip this section :)</i></p>

            <p><a href="https://en.wikipedia.org/wiki/Skeletal_animation">Skeletal animation</a> is by far the most popular method for animating 3D models. It is pretty simple conceptually: instead of animating the actual model, you animate a virtual highly simplified <i>skeleton</i> of the model, and the model itself is glued to this skeleton, like meat to the bones. Here's how it looks, roughly:</p>

            <center><video autoplay muted loop class="video-embed"><source src="/blog/media/gltf-animation/suzanne.mp4" type="video/mp4"></video></center>

            <p>Here's how the vertices of the model are glued to different bones (red is a lot of glue, blue is no glue):</p>

            <center><img src="/blog/media/gltf-animation/suzanne_weights.png" class="image-embed"></center>

            <p>Typically, each mesh vertex is glued to several bones with different weights to provide smoother animations, and the resulting transformation of the vertex is interpolated between these bones. If gluing each vertex to just a single bone, the transitions between different parts of the model (e.g. typically human shoulders, elbows and knees) will experience unpleasant artifacts when animated:</p>

            <center><video autoplay muted loop class="video-embed"><source src="/blog/media/gltf-animation/suzanne_artifacts.mp4" type="video/mp4"></video></center>

            <p>Another crucial part of this method is that it is <i>hierarchical</i>: the bones form a tree, with child bones inheriting their parent's transformation. In this example model, the two <code>ear</code> bones are children to the <code>head</code> bone, which is the root of the skeleton. Only the <code>head</code> bone is explicitly rotated up and down; the <code>ears</code> inherit this rotation from the <code>head</code> bone.</p>

            <p>This is for the same reason why most game engines use object hierarchies. When you have a mosquito on a helmet on a man in a car on a moving carrier ship, it's quite tiresome and error-prone to define the movement of all these objects separately. Instead, one would define the ship's movement, and specify that the objects form a hierarchy, with the children inheriting the parent's movement. The mosquito would be a child of the helmet, the helmet &ndash; a child of the man, and so on.</p>

            <p>Likewise, it is much easier to specify that the human's shoulder is rotating (and the whole arm rotating as per being a child of the shoulder), instead of computing the proper rotations for each of the arm's bone.</p>

            <h2 id="section-pros-cons">Pros'n'cons</h2>

            <p>Compared to the alternative method &ndash; <a href="https://en.wikipedia.org/wiki/Morph_target_animation">morph-target animation</a>, which stores all vertices' positions for each animation frame (and is also supported by glTF), &ndash; it has some advantages:</p>

            <ul>
                <li>It requires less storage &ndash; the skeleton is much smaller than the model</li>
                <li>Less data streaming is required per frame (only the bones, as opposed to the whole mesh, &ndash; although there are ways to store the whole animation on the GPU)</li>
                <li>It is (arguably) easier to work with for an artist</li>
                <li>It decouples animation from a specific model &ndash; you can have the same walking animation applied to many different models with different numbers of vertices</li>
                <li>It is much easier to integrate into procedural animation &ndash; say, you want to constrain a character's foot not to get through terrain; with skeletal animation, you only need to add constraints to a few bones</li>
            </ul>

            <p>It has a couple of downsides, though:</p>

            <ul>
                <li>You need to properly parse/decode the animation format you're using (this is harder than it sounds)</li>
                <li>You need to compute the transform for each bone for each animated model, which can be costly and also tricky (though one could do that using compute shaders)</li>
                <li>You need to somehow transfer the bones data to the GPU, which are not a vertex attribute and might not fit into uniforms</li>
                <li>You need to apply the bone transforms in the vertex shader, making this shader something like 4x slower than usual (still much cheaper than the typical fragment shader, though)</li>
            </ul>

            <p>It isn't as bad as it sounds, though. Let's dive into how you'd implement that, bottom-up.</p>

            <h2 id="section-bone-transforms">Bone transforms</h2>

            <p>So, we need to transform our mesh vertices somehow, on the fly. Each bone defines a certain transformation, &ndash; typically composed of scaling, rotation and translation. Even if you don't need scaling and translation, and your bones only rotate (which is reasonable for many realistic models &ndash; try moving your shoulder half a meter out of the shoulder socket!), the rotation can still happen around different centers of rotation (e.g. when an arm rotates around a shoulder, the hand also rotates around the shoulder and not around the hand bone origin), meaning you still need translations anyway.</p>

            <p>The most general way to support all this is to simply store a \(3\times 4\) <a href="https://en.wikipedia.org/wiki/Affine_transformation"><i>affine transformation</i></a> matrix per each bone. This transformation is usually the composition of scaling, rotation and translation (applied in that order), expressed as a matrix in <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates"><i>homogeneous coordinates</i></a> (this is a mathematical trick to express translations as matrices, among other things).</p>

            <p>Instead of using a matrix (which is 12 floats), we could separately store a translation vector (3 floats), a rotation quaternion (4 floats), and possibly a uniform (1 float) or non-uniform (3 floats) scaling vector, giving 7, 8 or 10 floats in total. However, <a href="#section-passing-transforms">as we'll see later</a>, it is easier to pass these transformations to a shader if the total number of components is a multiple of 4. So, my favourite options are translation + rotation + uniform scale (8 floats) or a full-fledged matrix (12 floats).</p>

            <p>In any case, these transformations should already account for the parent's transformations as well (we'll do this <a href="#section-global-transforms">a bit later</a>). Let's call them <i>global transforms</i>, instead of <i>local transforms</i> which don't account for the parents. So, we have a recursive formula like this:</p>

            \[ \text{globalTransform(bone)} = \text{globalTransform(parent)} \cdot \text{localTransform(bone)} \]

            <p>If a bone doesn't have a parent, its <code>globalTransform</code> coincides with the <code>localTransform</code>. We'll talk about where these <code>localTransform</code>s come from later in the article.</p>

            <h2 id="section-composing-transforms">Composing transforms</h2>

            <p>By the way, the above equation might be a bit misleading. If we store transforms as matrices, how do we multiply two \(3\times 4\) matrices? This is against the rules of matrix multiplication! If we store them as (translation,rotation,scale) triplets, how do we compose them?</p>

            <p>In the matrix case, the usage of \(3\times 4\) matrices is actually an optimization. What we really need are \(4\times 4\) matrices, which are easy to multiply. It just so happens that affine transformations are always of the form</p>

            \[ \begin{pmatrix} a_{11} & a_{12} & a_{13} & t_{1} \\ a_{21} & a_{22} & a_{23} & t_{2} \\ a_{31} & a_{32} & a_{33} & t_{3} \\ 0 & 0 & 0 & 1 \end{pmatrix} \]

            <p>So, there is no point in actually <i>storing</i> the 4-th row, but we need to <i>restore</i> it when doing computations. <i>In fact, the <a href="https://en.wikipedia.org/wiki/Affine_group">invertible affine transformations</a> are a subgroup of the group of <a href="https://en.wikipedia.org/wiki/General_linear_group">all invertible matrices</a></i>.</p>

            <p>The recipe for matrices is as follows: append a \( \begin{pmatrix}0 & 0 & 0 & 1\end{pmatrix} \) row, multiply the resulting \(4\times 4\) matrices, and discard the last row of the result, which will also be \( \begin{pmatrix}0 & 0 & 0 & 1\end{pmatrix} \). There are ways to do this more efficiently by explicitly applying the left matrix to the columns of the right matrix, but the general formula is still the same.</p>

            <p>Now, what's with storing the transforms explicitly as translations, rotations, and scalings, how do we multiply them? Well, there is just a formula for that! Let's denote our transformations as \( (T,R,S) \) &ndash; Translation vector, Rotation operator and Scaling factor. The effect of this transformation on a point \(p\) is \( (T,R,S)\cdot p = T + R\cdot(S\cdot p) \). Let's see what happens if we combine two such transformations:</p>

            \[\color{blue}{(T_2,R_2,S_2)}\cdot\color{red}{(T_1,R_1,S_1)}\cdot p = \color{blue}{(T_2,R_2,S_2)}\cdot(\color{red}{T_1} + \color{red}{R_1S_1}p) = \\
            = \color{blue}{T_2}+\color{blue}{R_2S_2}(\color{red}{T_1}+\color{red}{R_1S_1}p) = (\color{blue}{T_2}+\color{blue}{R_2S_2}\color{red}{T_1}) + (\color{blue}{R_2}\color{red}{R_1})(\color{blue}{S_2}\color{red}{S_1})p\]

            <p><i>I've used the fact that uniform scaling <a href="https://en.wikipedia.org/wiki/Commuting_matrices">commutes</a> with rotations. In fact, it commutes with anything!</i></p>

            <p>So, the formula for multiplying two transformations in this form is</p>

            \[ \color{blue}{(T_2,R_2,S_2)}\cdot\color{red}{(T_1,R_1,S_1)} = (\color{blue}{T_2}+\color{blue}{R_2S_2}\color{red}{T_1}, \color{blue}{R_2}\color{red}{R_1}, \color{blue}{S_2}\color{red}{S_1}) \]

            <p>Note that \(R\) is the rotation <i>operator</i> (i.e. rotation <i>matrix</i>), not the rotation <i>quaternion</i>. For a rotation quaternion \(Q\), the composition of rotations doesn't change, but the way it acts on a vector <i>does</i> change:</p>

            \[ R\cdot p = Q\cdot p \cdot Q^{-1} \]

            \[ (T,Q,S)\cdot p = T + S\cdot(Q\cdot p \cdot Q^{-1}) \]

            \[ \color{blue}{(T_2,Q_2,S_2)}\cdot\color{red}{(T_1,Q_1,S_1)} = (\color{blue}{T_2}+\color{blue}{S_2Q_2}\color{red}{T_1}\color{blue}{Q_2^{-1}}, \color{blue}{Q_2}\color{red}{Q_1}, \color{blue}{S_2}\color{red}{S_1}) \]

            <p>Also note that this trick <b>doesn't work</b> for non-uniform scaling: essentially, if \(R\) is a rotation and \(S\) is a non-uniform scaling, there is no way to express the product \( S\cdot R \) as something like \( R'\cdot S' \) for some other rotation \(R'\) and non-uniform scaling \(S'\). In this case, it's simpler to just use matrices instead.</p>

            <h2 id="section-vertex-shader">The vertex shader</h2>

            <p>That was quite a mouthful of explanations! Let's get to some real code, specifically the vertex shader. I'll use GLSL, but the specific language or graphics API doesn't matter much here.</p>

            <p>Say we've passed the per-bone <i>global transforms</i> into the shader somehow (we'll talk about it in a minute). We also need some way to tell which vertex is connected to which bone and with what weight. This is typically done with two extra vertex attributes: one for the bone ID's and one for the bone weights. Usually you don't need more than 256 bones per model, and you also don't need that much precision for the weights, so one can use integer <code>uint8</code> attribute for the ID's and normalized <code>uint8</code> attribute for the weights. Since the attributes are at most 4-dimensional in most graphics APIs, we usually only allow a vertex to be glued to 4 bones or less. If, for example, a bone is glued to only 2 bones, we just append two random bone ID's with zero weights and call it a day.</p>

            <p>Enough talking:</p>

            <pre><code class="language-glsl block">// somewhere: mat4x3 globalBoneTransform[]

uniform mat4 uModelViewProjection;

layout (location = 0) in  vec3 vPosition;
// ...other attributes...
layout (location = 4) in ivec4 vBoneIDs;
layout (location = 5) in  vec4 vWeights;

void main() {
    vec3 position = vec3(0.0);
    for (int i = 0; i < 4; ++i) {
        mat4x3 boneTransform = globalBoneTransform[vBoneIDs[i]];
        position += vWeights[i] * (boneTransform * vec4(vPosition, 1.0));
    }

    gl_Position = uModelViewProjection * vec4(position, 1.0);
}</code></pre>

            <p><i>In GLSL, for a vector <code>v</code>, <code>v[0]</code> is the same as <code>v.x</code>, <code>v[1]</code> is <code>v.y</code> and so on.</i></p>

            <p>What we do here is</p>

            <ol>
                <li>Iterate over the 4 bones the vertex is attached to</li>
                <li>Read the ID of the bone <code>vBoneIDs[i]</code> and fetch it's <i>global transform</i></li>
                <li>Apply the global transform to the vertex position in homogeneous coordinates <code>vec4(vPosition, 1.0)</code></li>
                <li>Add the weighted result to the resulting vertex <code>position</code></li>
                <li>Apply the usual <a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices"><code>MVP</code> matrix</a> to the result</li>
            </ol>

            <p>This whole process is also called <i>skinning</i>, or a bit more specifically <i>linear blend skinning</i>, because we're linearly interpolating between the result of skinning by several bones.</p>

            <p><i>In GLSL <code>matNxM</code> means N columns and M rows, so <code>mat4x3</code> is actually a 3x4 matrix. I love standards.</i></p>

            <p>If you're not sure that your weights sum up to 1, we can also divide by their sum in the end (although you better <i>be sure</i> they sum up to 1!):</p>

            <pre><code class="language-glsl block">position /= dot(vWeights, vec4(1.0));</code></pre>

            <p>If the sum of weigts isn't equal to 1, you'll get distortions. Essentially, your vertex will get closer to or further from the model origin (depending on whether the sum is < 1 or > 1). This is related to the <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix.html">perspective projection</a> and also to the fact that affine transformations don't form a <a href="https://en.wikipedia.org/wiki/Vector_space">linear space</a>, but they do form an <a href="https://en.wikipedia.org/wiki/Affine_space">affine space</a>.</p>

            <p>If we also have normals, those need to be transformed as well. The only difference is that <i>position</i> is a <i>point</i>, while a <i>normal</i> is a <i>vector</i>, so it has a different representation in homogeneous coordinates (we append 0 as the w coordinate instead of appending 1). We might also want to normalize it afterwards, to account for scaling:</p>

            <pre><code class="language-glsl block">// somewhere: mat4x3 globalBoneTransform[]

uniform mat4 uModelViewProjection;

layout (location = 0) in  vec3 vPosition;
layout (location = 1) in  vec3 vNormal;
// ...other attributes...
layout (location = 4) in ivec4 vBoneIDs;
layout (location = 5) in  vec4 vWeights;

vec3 applyBoneTransform(vec4 p) {
    vec3 result = vec3(0.0);
    for (int i = 0; i < 4; ++i) {
        mat4x3 boneTransform = globalBoneTransform[vBoneIDs[i]];
        result += vWeights[i] * (boneTransform * p);
    }
    return result;
}

void main() {
    vec3 position = applyBoneTransform(vec4(vPosition, 1.0));
    vec3 normal = normalize(applyBoneTransform(vec4(vNormal, 0.0)));

    // ...
}</code></pre>

            <p><i>Note that if you're using non-uniform scaling, or you want to do eye-space lighting, things get <a href="http://www.songho.ca/opengl/gl_normaltransform.html">a bit more complicated</a>.</i></p>

            <h2 id="section-passing-transforms">Passing the transforms to the shader</h2>

            <p><i>I'm mostly using OpenGL 3.3 for my graphics stuff, so the details of this section are OpenGL-specific, bit I believe the general concepts apply to any graphics API.</i></p>

            <p>Most skeletal animation tutorials suggest using <i>uniform arrays</i> for the bone transforms. This is a simple working approach, but it can be a bit problematic:</p>

            <ul>
                <li>OpenGL has a limit on the number of uniforms. OpenGL 3.0 guarantees at least 1024 <i>components</i>, meaning single elements of our matrices, loosely speaking. So for <code>mat4x3</code>, which takes 12 components, we're bound by having \( 1024/12 \approx 85 \) bones per model. This is already quite a lot, so it might actually be enough. Though, a lot of the uniforms are already used for other stuff (matrices, textures, etc), so we usually have less free uniforms. <i>In reality, we usually have <a href="https://opengl.gpuinfo.org/displaycapability.php?name=GL_MAX_VERTEX_UNIFORM_COMPONENTS">from 4096 to 16384 components</a>.</i></li>
                <li>We'll have to update the uniform array per each animated model, meaning a lot of OpenGL calls & no instancing.</li>
            </ul>

            <p>The problem can be somewhat fixed by using <a href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object"><i>uniform buffers</i></a>:</p>

            <ul>
                <li>By spefication, they have more memory available, but still not that much &ndash; <a href="https://opengl.gpuinfo.org/displaycapability.php?name=GL_MAX_UNIFORM_BLOCK_SIZE">typically 64 KB</a> for a buffer.</li>
                <li>We don't need to upload all the bone transforms to uniforms, instead we can upload all the transforms for all model to the buffer all in one go. We still have to call <code>glBindBufferRange</code> for each model to speficy where this model's bone data is, so, no instancing.</li>
            </ul>

            <p>If you're using OpenGL 4.3 or higher, you can simply store all the transforms in a <a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object"><i>shader storage buffer object</i></a>, which have basically unlimited size. Otherwise, you can use <a href="https://www.khronos.org/opengl/wiki/Buffer_Texture"><i>buffer textures</i></a>, which are a way of accessing an arbitrary data buffer pretending it to be a 1D texture. A buffer texture doesn't store anything itself, it only references an existing buffer. It works like this:</p>

            <ol>
                <li>We create a usual OpenGL <code>GL_ARRAY_BUFFER</code> and fill it with all models' bone transforms each frame, stored as e.g. row-wise matrices (12 floats) or TRS triplets with uniform scaling (8 floats)</li>
                <li>We create a <code>GL_BUFFER_TEXTURE</code> and call <code>glTexBuffer(GL_BUFFER_TEXTURE, GL_RGBA32F, bufferID);</code> &ndash; <code>RGBA32F</code> is the <i>pixel format</i> of this texture, i.e. 4 floats (12 bytes) per pixel (so we need 3 pixels per matrix or 2 pixels per TRS triplet)</li>
                <li>We attach the texture to a <code>samplerBuffer</code> uniform in the shader</li>
                <li>We read the corresponding pixels in the shader with <code>texelFetch</code> and convert them to bone transforms</li>
            </ol>

            <p>With instanced rendering, a shader for this might look like this:</p>

            <pre><code class="language-glsl block">uniform samplerBuffer uBoneTransformTexture;
uniform int uBoneCount;

mat4x3 getBoneTransform(int instanceID, int boneID) {
    int offset = (instanceID * uBoneCount + boneID) * 3;
    mat3x4 result;
    result[0] = texelFetch(uBoneTransformTexture, offset + 0);
    result[1] = texelFetch(uBoneTransformTexture, offset + 1);
    result[2] = texelFetch(uBoneTransformTexture, offset + 2);
    return transpose(result);
}</code></pre>

            <p>Note that we assemble the matrix as a 4x3 matrix (called <code>mat3x4</code> in GLSL), but reading the <i>rows</i> from the texture and writing it to the <i>columns</i> of the matrix, and then transposing it, switching rows and columns. This is simply because GLSL uses <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major</a> matrices.</p>

            <h2 id="section-recap">Phew</h2>

            <p>Let's recap a little:</p>

            <ul>
                <li>To animate a model, we attach each vertex to at most 4 bones of a virtual skeleton, with 4 different weights</li>
                <li>Each bone defines a <i>global transform</i> that needs to be applied to the vertices</li>
                <li>For each vertex, we apply the transforms of the 4 bones it is attached to, and average the result using weights</li>
                <li>We store the transforms as TRS triplets or as 3x4 affine transform matrices</li>
                <li>We store the transforms in uniform arrays, uniform buffers, buffer textures, or shader storage buffers</li>
            </ul>

            <p>What we're left with is where do those <i>global transforms</i> come from?</p>

            <h2 id="section-global-transforms">Global transforms</h2>

            <p>Well, actually, we already know where the <i>global transforms</i> come from: they're computed from <i>local transforms</i>:</p>

            \[ \text{globalTransform(bone)} = \text{globalTransform(parent)} \cdot \text{localTransform(bone)} \]

            <p>A naive approach for computing this would be something like a recursive function that computes all transforms:</p>

            <pre><code class="language-cpp block">mat4 globalTransform(int boneID) {
    if (int parentID = parent[boneID]; parentID != -1)
        return globalTransform(parentID) * localTransform[boneID];
    else
        return localTransform[boneID];
}</code></pre>

            <p>or the same thing, but with manual unrolling of the tail recursion:</p>

            <pre><code class="language-cpp block">for (int boneID = 0; boneID < nodeCount; ++boneID) {
    globalTransform[boneID] = identityTransform();
    int current = boneID;
    while (current != -1) {
        globalTransform[boneID] = localTransform[current] * globalTransform[boneID];
        current = nodeParent[current];
    }
}</code></pre>

            <p>Both these methods are fine, but they compute way more matrix multiplications than necessary. Remember, we're supposed to do this on every frame, for every animated model!</p>

            <p>A better way to compute global transforms is to do it from parents to children: if the parent's global transform is already computed, all we need to do is one matrix multiplication per bone.</p>

            <pre><code class="language-cpp block">// ... somehow make sure parent transform is already computed
if (int parentID = parent[boneID]; parentID != -1)
    globalTransform[boneID] = globalTransform[parentID] * localTransform[boneID];
else
    globalTransform[boneID] = localTransform[boneID];</code></pre>

            <p>To ensure that parent computations go before children, you'd need some <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a> over the bone tree to properly order the bones. An arguably simpler solution is to compute the <a href="https://en.wikipedia.org/wiki/Topological_sorting"><i>topological sort</i></a> of the bone tree (an enumeration of bones such that parents go before children) in advance and use it every frame. <i>(Btw, computing the toposort boils down to DFS anyway.)</i> An even simpler solution is to ensure that the bone ID's effectively <i>are</i> a topological sorting, i.e. that <code>parent[boneID] < boneID</code> always holds. This can be done by reordering the bones (and mesh vertex attributes!) at load time, or by requiring the artists to order their bones this way :) <i>Uhm, their models' bones, that is.</i></p>

            <p>In the latter case, the implementation is the simplest (and the fastest):</p>

            <pre><code class="language-cpp block">for (int boneID = 0; boneID < nodeCount; ++boneID) {
    if (int parentID = parent[boneID]; parentID != -1)
        globalTransform[boneID] = globalTransform[parentID] * localTransform[boneID];
    else
        globalTransform[boneID] = localTransform[boneID];
}</code></pre>

            <p>But where do the <i>local transforms</i> come from?</p>

            <h2 id="section-local-transforms">Local transforms</h2>

            <p>This is where things get a bit quirky (as if they weren't already). You see, it is usually convenient to specify local bone transformations in some special coordinate system instead of the world coordinates. If I rotate my arm, it would make sense that the origin of the local coordinate system is at the center of rotation, and not somewhere at my feet, so that I don't have to explicitly account for this translation. Also, if I rotate it up and down, as if waving to someone at a distance, I'd really want it to be a rotation around some coordinate axis (maybe, X) in the local space, regardless of how the model is oriented in the model space and the world space.</p>

            <p>What I'm saying is that we want a special <i>coordinate system (CS)</i> for each bone, and we want the bone local transformations to be described in terms of this coordinate system.</p>

            <p>However, the vertices of the model are in, well, the model's coordinate system (that's the definition of this coordinate system). So, we need a way to transform the vertices into the local coordinate system of the bone first. This is called an <i>inverse bind matrix</i>, probably because it sounds really cool.</p>

            <p>Ok, we've transformed the vertices to the local CS of a bone, and applied the animation transform (we'll get to them in a moment) in this local CS. Is that all? Remember that the next thing is to combine this with the transform of the parent bone, which will be <i>in it's own coordinate system</i>! So we need another thing: transform the vertex from the bone local CS to the parent's local CS. This can be done using the inverse bind matrices, by the way: transform the vertex from the bone's local CS back to the model CS, and then transform it to the parent's local CS:</p>

            \[ \operatorname{convertToParentCS(node)} = \operatorname{inverseBindMatrix(parent)} \cdot \operatorname{inverseBindMatrix(node)}^{-1} \]

            <p>We can also think of it as follows: a specific bone transforms vertices to it's local CS, applies animation, then transforms them back; then it's parent transforms the vertices to it's own local CS, applies it's own animation, and transforms them back; and so on.</p>

            <p><i>Actually, we don't actually need this <code>converToParent</code> transform explicitly when working with glTF, but it is useful to think about it nevertheless.</i></p>

            <p>There's one more thing. Sometimes, it is convenient (for the artist, or for the 3D modelling software) to attach the vertices to the bones not in the model's default state, but in some transformed state, called the <i>bind pose</i>. So, we might need another transformation which, for each bone, transforms the vertex to the CS that this bone expects the vertices to be in. I know, it sounds confusing, but <i>bear with me</i>, we won't actually need this transformation :)</p>

            <center><details>
            <summary>Click to see a bear</summary>
            <center><img src="/blog/media/gltf-animation/cat.jpg" class="image-embed"></center>
            <center><i>This is not a bear but, in fact, my cat. Fooled you! :)</i></center>
            </details></center>

            <p><i>Blender uses world-space vertex positions as the bind pose. If your model is located 20 units along the X-axis from the origin, it's raw vertex positions will be around X=20, and the inverse bind matrices will compensate for that. This effectively renders animated models exported from Blender impossible to use without animation.</i></p>

            <h2 id="section-transform-recap">Transform recap</h2>

            <p>In total, we have the following sequence of transformations applied to a vertex:</p>

            <ol>
                <li>Convert it to the model bind pose</li>
                <li>Transform to bone local CS (inverse bind matrix)</li>
                <li>Apply the actual damn animation (specified in local CS)</li>
                <li>Transform back from bone local CS to model CS</li>
                <li>If the bone has a parent, repeat steps 2-5 for the parent bone</li>
            </ol>

            <p>Now, the thing is that each format defines its own ways of specifying these. In fact, some of these transforms may even be absent &ndash; it is supposed that they are included in the other transforms.</p>

            <p>Let's finally talk about glTF.</p>

            <h2 id="section-gltf">glTF 101</h2>

            <p><a href="https://www.khronos.org/gltf/">glTF</a> is a pretty cool 3D scene authoring format developed by <a href="https://www.khronos.org/">Khronos Group</a> &ndash; the folks behind OpenGL, OpenCL, Vulkan, WebGL, and SPIR-V, among other numerous things. I've already said why I think it is a cool format in the beginning of the article, so let's talk a bit more on the details.</p>

            <p><i>Here's the <a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">specification</a> for glTF-2.0. It is so good that learning the format can be done by just reading the spec.</i></p>

            <p>A glTF scene is composed of <i>nodes</i>, which are abstract and can mean many things. A node can be a rendered mesh, a camera, a <a href="https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md">light source</a>, a skeleton bone, or just an aggregate parent for other nodes. Each node has its own affine transformation, which defines its position, rotation and scale with respect to the parent node (or the world origin, if it doesn't have a parent).</p>

            <p>glTF describes all binary data via <i>accessors</i> &ndash; basically, references to a part of some binary buffer containing an array (potentially with non-zero gaps between elements) with a specified type (like e.g. a contiguous array of 100 <code>vec4</code>'s with <code>float32</code> components starting at byte <code>6340</code> in this particular binary file, stuff like that).</p>

            <p>If a mesh node uses skeletal animation, it has a list of <code>joints</code> which are ID's of glTF nodes that specify the bones of the skeleton. <i>(Actually, the mesh references a skin, which in turn contains the joints.)</i> These joints form a hierarchy &ndash; they are still glTF nodes, so they can have parents and children. Note that there's no <i>armature</i> or <i>skeleton</i> node &ndash; just the bone nodes; likewise the animated mesh isn't a child of bone nodes or an armature node, but references them indirectly <i>(although exporting software might add an artificial armature node, e.g. Blender does that, &ndash; but it isn't required by glTF)</i>.</p>

            <p>Each vertex attribute of a mesh (actually, of a mesh <i>primitive</i>) &ndash; positions, normals, UV's, etc &ndash; is a separate accessor. When a mesh uses skeletal animation, it also has bone ID and weight attributes, which are also some accessors. The actual animation of the bones is also stored in accessors.</p>

            <p>Along with the description of a <i>skinned mesh</i>, a glTF file may also contain some actual <i>animations</i> &ndash; in essence, instructions on how to change the 3rd transform from the list above.</p>

            <h2 id="section-gltf-transforms">glTF transforms</h2>

            <p>Here's how glTF stores all the transforms in the <a href="#section-transform-recap">1-5 list above</a>:</p>

            <ol>
                <li>Model bind pose is supposed to be either already applied to the model, or premultiplied to inverse bind matrices. In other words, simply forget about bind pose for glTF.</li>
                <li>The per-bone inverse bind matrices are specified as yet another accessor &ndash; an array of 4x4 matrices (which are required to be affine transformations, so only the first 3 rows are interesting).</li>
                <li>The actual animation can be defined externally (e.g. procedural animation), or stored as keyframe splines for the rotation, translation and scale of each bone. The important thing here is that these are...</li>
                <li>...<i>combined</i> with the transformation from local CS to the parent's local CS. So, the <code>convertToParent</code> and the bone animation are combined.</li>
                <li>The parents are defined by the node hierarchy, but since we've already applied the <code>convertToParent</code> transform, we don't need the parent's inverse bind matrix, so we only repeat steps 3-5 for the parent, if any.</li>
            </ol>

            <p>So, when working with glTF, the global transform for a bone looks something like</p>

            \[ \operatorname{global(bone)} = \ldots \cdot \operatorname{animation(grand-parent)}\cdot\operatorname{animation(parent)}\cdot \\ \cdot \operatorname{animation(bone)}\cdot\operatorname{invBind(bone)} \]

            <p>And in code this would be </p>

            <pre><code class="language-cpp block">// assuming parent[boneID] < boneID holds

// somehow compute the per-bone local animations
// (including the bone-CS-to-parent-CS transform)
for (int boneID = 0; boneID < boneCount; ++boneID) {
    transform[boneID] = ???;
}

// combine the transforms with the parent's transforms
for (int boneID = 0; boneID < boneCount; ++boneID) {
    if (int parentID = parent[boneID]; parentID != -1) {
        transform[boneID] = transform[parentID] * transform[boneID];
    }
}

// pre-multiply with inverse bind matrices
for (int boneID = 0; boneID < boneCount; ++boneID) {
    transform[boneID] = transform[boneID] * inverseBind[boneID];
}</code></pre>

            <p>This <code>transform[]</code> array is the <code>globalBoneTransform[]</code> array in the <a href="#section-vertex-shader">vertex shader</a> above.</p>

            <p>Not that complicated after all! Just need to figure the right order to multiply a bunch of seemingly random matrices :)</p>

            <h2 id="section-gltf-animations">glTF animations</h2>

            <p>Lastly, let's talk about how to apply animations stored directly in glTF files. They are specified as <i>keyframe splines</i> for the rotation, scale and translation of each bone.</p>

            <p>Each individual spline is called a <i>channel</i>. It defines:</p>

            <ul>
                <li>Which node (e.g. a skeleton bone) it is applied to</li>
                <li>Which parameter (rotation, scale or translation) it affects</li>
                <li>An accessor for the keyframe timestamps</li>
                <li>An accessor for the keyframe values (<code>vec4</code> quaternions for rotation, <code>vec3</code> vectors for scale or translation)</li>
                <li>An interpolation method &ndash; <code>STEP</code>, <code>LINEAR</code>, or <code>CUBICSPLINE</code></li>
            </ul>

            <p><i>For rotations, <code>LINEAR</code> actually means <a href="https://en.wikipedia.org/wiki/Slerp">spherical linear</a>.</i></p>
            <p><i>For <code>CUBICSPLINE</code> interpolation, each keyframe stores not one, but 3 values &ndash; the spline value and two tangent vectors.</i></p>

            <p>So, the way we build up the local transform for a bone is:</p>

            <ul>
                <li>Sample the splines for the rotation, translation and scale for this bone at the current moment of time</li>
                <li>Combine them together to form the local transformation matrix</li>
            </ul>

            <p>For a translation by vector \( (x,y,z) \) the corresponding matrix is</p>

            \[ \begin{pmatrix} 1 & 0 & 0 & x \\ 0 & 1 & 0 & y \\ 0 & 0 & 1 & z \\ 0 & 0 & 0 & 1 \end{pmatrix} \]

            <p>For a non-uniform scaling vector \( (x,y,z) \) the matrix is</p>

            \[ \begin{pmatrix} x & 0 & 0 & 0 \\ 0 & y & 0 & 0 \\ 0 & 0 & z & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \]

            <p>and for a unit rotation quaternion \( (x,y,z,w) \) you can find the matrix in <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix">the wiki article</a> &ndash; it will be a 3x3 matrix which you put into the top-left corner of a 4x4 matrix, like this:</p>

            \[ \begin{pmatrix} 1-2(y^2+z^2) & 2(xy-zw) & 2(xz+yw) & 0 \\ 2(xy+zw) & 1-2(x^2+z^2) & 2(yz-xw) & 0 \\ 2(xz-yw) & 2(yz+xw) & 1-2(x^2+y^2) & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} \]

            <p>As we've discissed earlier, these matrices are 4x4, but they are really affine transformations, so the interesting stuff only happens in the first 3 rows.</p>

            <h2 id="section-sampling-animation-splines">Sampling animation splines</h2>

            <p>To address the last bit &ndash; efficiently sampling the animation splines &ndash; we can gather the spline into a class like this:</p>

            <pre><code class="language-cpp block">template &lt;typename T&gt;
struct animation_spline {

    // ...some methods...

private:
    std::vector&lt;float&gt; timestamps_;
    std::vector&lt;T&gt; values_;
};</code></pre>

            <p>Now, an obvious API decision would be to make a method that returns the spline's value at some specific time:</p>

            <pre><code class="language-cpp block">template &lt;typename T&gt;
T value(float time) const {
    assert(!timestamps_.empty());

    if (time <= timestamps_[0])
        return values_[0];

    if (time >= timestamps_[1])
        return values_[1];

    for (int i = 1; i < timestamps_.size(); ++i) {
        if (time <= timestamps_[i]) {
            float t = (time - timestamps_[i - 1]) / (timestamps_[i] - timestamps_[i - 1]);
            return lerp(values_[i], values_[i + 1], t);
        }
    }
}</code></pre>

            <p><i>The <code>lerp</code> call should be changed depending on interpolation type and whether this is rotations or not.</i></p>

            <p>This works, but we can improve it in two ways. First of all, our keyframe timestamps are guaranteed to be sorted, so intead of a linear search we can do a <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">binary search</a>:</p>

            <pre><code class="language-cpp block">template &lt;typename T&gt;
T value(float time) const {
    auto it = std::lower_bound(timestamps_.begin(), timestamps_.end(), time);
    if (it == timestamps_.begin())
        return values_.front();
    if (it == timestamps_.end())
        return values_.back();

    int i = it - timestamps_.begin();

    float t = (time - timestamps_[i - 1]) / (timestamps_[i] - timestamps_[i - 1]);
    return lerp(values_[i - 1], values_[i], t);
}</code></pre>

            <p>Secondly, when playing an animation, we always traverse it linearly, from start to end, so we could optimize it further by storing the current keyframe index. This isn't a property of animation inself, though, so let's make another class:</p>

            <pre><code class="language-cpp block">template &lt;typename T&gt;
struct animation_spline {

    // ...

private:
    std::vector&lt;float&gt; timestamps_;
    std::vector&lt;T&gt; values_;

    friend class animation_sampler&lt;T&gt;;
};

template &lt;typename T&gt;
struct animation_sampler {
    animation_spline&lt;T&gt; const & animation;
    int current_index;

    T sample(float time) {
        while (current_index + 1 < animation.timestamps_.size() && time > animation.timestamps_[current_index + 1])
            ++current_index;

        if (current_index + 1 >= animation.timestamps_.size())
            current_index = 0;

        float t = (time - timestamps_[current_index]) / (timestamps_[current_index + 1] - timestamps_[current_index]);
        return lerp(values_[current_index], values_[current_index + 1], t);
    }
};</code></pre>

            <p>I didn' test this exact code, but I'm using <a href="https://bitbucket.org/lisyarus/psemek/src/master/libs/gfx/include/psemek/gfx/gltf_animation.hpp">very similar code</a> in my own projects.</p>

            <h2 id="section-what-a-journey">What a journey</h2>

            <p>I hope you liked the article and learnt at least something new today :)</p>

            <p>If I messed up something (which I'm absolutely sure I did), feel free to <a href="/blog/contacts.html">reach out to me</a> somewhere &ndash; I'll be happy to fix anything. And, as always, thanks for reading!</p>

            <div id="end-section"></div>
            <div id="blog-footer"></div>
        </div>
        <script async src="/blog/scripts/header.js"></script>
    </body>
</html>